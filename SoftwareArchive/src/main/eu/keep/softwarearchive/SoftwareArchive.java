/*
* $Revision$ $Date$
* $Author$
* $header:
* Copyright (c) 2009-2011 Tessella plc.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* For more information about this project, visit
*   http://www.keep-project.eu/
*   http://emuframework.sourceforge.net/
* or contact us via email:
*   blohman at users.sourceforge.net
*   dav_m at users.sourceforge.net
*   bkiers at users.sourceforge.net
* Developed by:
*   Tessella plc <www.tessella.com>
*   Koninklijke Bibliotheek <www.kb.nl>
*   KEEP <www.keep-project.eu>
* Project Title: Software Archive (SWA)$
*/

package eu.keep.softwarearchive;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

import org.apache.log4j.Logger;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

import javax.xml.ws.Endpoint;
import javax.xml.ws.soap.SOAPBinding;

import org.apache.cxf.jaxws.EndpointImpl;

/**
 * Software Archive main class
 * Starts the software archive: connects to the database, publishes the endpoints
 * Replaces "SoftwareArchivePortType_SoftwareArchivePort_Server", a Java class
 * generated by Apache CXF wsdl2java (when given '-server' flag). Some functionality from
 * that class has been copied here.
 * 
 * @author David Michel
 * @author Bram Lohman
 */
public class SoftwareArchive {

    private static final Logger LOG = Logger.getLogger(SoftwareArchive.class.getName());
    private final static String propertiesFile = "user.properties";
    private static Properties props;

    private SoftwarePackageDAO  softwarePackDAO;
    private Connection          softwareDatabaseConnection;

    /**
     * Constructor
     * @param props The properties file
     * @throws IOException 
     * @throws IOException
     */
    public SoftwareArchive(Properties props) throws IOException {
        // set up connection to databases
        int connectionAttempts = 5;

        Map<String, String> pv = new HashMap<String, String>();
        pv.put("driver",    props.getProperty("h2.db.driver"));
        pv.put("urlPref",   props.getProperty("h2.jdbc.prefix"));
        pv.put("url",       props.getProperty("h2.db.url"));
        pv.put("urlExist",  props.getProperty("h2.db.exists"));
        pv.put("urlSchema", props.getProperty("h2.db.schema"));
        pv.put("user",      props.getProperty("h2.db.user"));
        pv.put("pw",        props.getProperty("h2.db.userpassw"));
        
        for (String propVal : pv.keySet())
        {
        	if (pv.get(propVal) == null)
        		throw new IOException("Property '" + propVal + "' does not exist in file " + propertiesFile);
        }

        softwareDatabaseConnection = establishConnection(pv.get("driver"), pv.get("urlPref") + pv.get("url") + 
        		pv.get("urlExist") + pv.get("urlSchema"), pv.get("user"), pv.get("pw"), connectionAttempts);

        LOG.info("Setting up web services port...");
        softwarePackDAO = new H2SoftwarePackageDAO(softwareDatabaseConnection);
        Object implementor = new SoftwareArchivePortTypeImpl(softwarePackDAO);
        String address = props.getProperty("server.soap.address");
        Endpoint ep = new EndpointImpl(implementor);
        ep.publish(address);
        SOAPBinding binding = (SOAPBinding)ep.getBinding();
        binding.setMTOMEnabled(true);
    }

    /**
     * Start the software archive (runs indefinitely)
     * @param args
     * @throws Exception
     */
    public static void main(String args[]) throws Exception {

        SoftwareArchive sa = null;

        LOG.info("Starting server...");

        try {

            // Read the properties file
            props = getProperties(propertiesFile);
            sa = new SoftwareArchive(props);
            LOG.info("Server ready...");

            // Infinite loop
            while (true){
                Thread.sleep(5 * 60 * 1000);
            }
        }
        catch (IOException e) {
            LOG.fatal("Error occurred while setting up software archive: " + e.toString());
            throw new RuntimeException("Error occurred while setting up software archive: " + e.toString());
        } finally {
            if(sa != null) {
                sa.closeConnection();
            }
        }

    }

    /**
     * Loads the user.properties file
     * @param userPropertiesFileName Filename of the properties file
     * @return Properties object
     * @throws IOException
     */
    private static Properties getProperties(String userPropertiesFileName) throws IOException {

        // Read the properties file
        Properties props = new Properties();
        FileInputStream fis = null;

        try {
            fis = new FileInputStream(userPropertiesFileName);
            props.load(fis);
        }
        catch (FileNotFoundException e) {
            LOG.fatal("Failed to read properties file [" + userPropertiesFileName + "]: "
                    + e.toString());
            throw new IOException("Failed to read properties file [" + userPropertiesFileName + "]: "
                    + e.toString());
        }
        catch (IOException e) {
            LOG.fatal("Failed to read properties file [" + userPropertiesFileName + "]: "
                    + e.toString());
            throw new IOException("Failed to read properties file [" + userPropertiesFileName + "]: "
                    + e.toString());
        }

        finally {
            try {

                if (fis != null) {
                    fis.close();
                }
            }
            catch (Exception e) {
                // Hmm... hoping not to get this far into catching exceptions;
                // we'll just log it and proceed...
                LOG.info("Failed to close open file: [" + userPropertiesFileName + "]: "
                        + e.toString());
            }
        }

        LOG.info("Correctly read properties file: " + userPropertiesFileName);
        return props;
    }

    
    /**
     * Establish a connection to a database
     * @param driver Database driver to be used
     * @param dbUrl Database URL
     * @param dbUser Username
     * @param dbPasswd Password
     * @param nAttempt Number of attempted connections before quitting
     * @return A connection to the database 
     * @throws IOException If connecting to the database fails
     */
    private Connection establishConnection(String driver, String dbUrl, String dbUser,
            String dbPasswd, int nAttempt) throws IOException {

        Connection conn = null;
    	
        LOG.info("Setting up connection to archive database...");

        // Set up the db connection
        // Register the JDBC driver
        try {
            Class.forName(driver);
        }
        catch (ClassNotFoundException e) {
             LOG.fatal("Database driver not found: " + driver);
            throw new IOException("Database driver not found: " + e);
        }

        int iAttempt = 0;
        while (iAttempt < nAttempt) {
            try {
                conn = DriverManager.getConnection(dbUrl, dbUser, dbPasswd);
                break;
            }
            catch (SQLException e) {
                LOG.info("Attempt "+ iAttempt + " of " + nAttempt + " to connect to database...");
            }
            iAttempt++;
        }

        if (iAttempt >= nAttempt) {
             LOG.fatal("Failed to connect to database: " + dbUrl);
            throw new IOException("Failed to connect to database: " + dbUrl);
        }

        return conn;
    }

    /**
     * Closes the connection to the database
     * @throws IOException
     */
    public void closeConnection() throws IOException {
        try {
            softwareDatabaseConnection.close();
        }
        catch (SQLException e) {
            LOG.fatal("Failed to close connection to database");
            throw new IOException("Failed to close connection to database: " + e.toString());
        }
    }

}
